# The SPUD base schema
include "spud_base.rnc"
include "io.rnc"
#TODO: fix phase transition variables
lattice_type =
(
    ## SC: Simple Cubic
    element lattice {
        attribute name {"SC"},
        comment
        }|
    ## FCC: Face Centred Cubic
    element lattice {
        attribute name {"FCC"},
        comment
    }|
    ## BCC: Body Centred Cubic
    element lattice {
        attribute name {"BCC"},
        comment
    }|
    ## RANDOM: Randomise the positions of the particles in the lattice
    element lattice {
        attribute name {"RANDOM"},
        ## Variance of the normal distributions
        element variance {real},
        ## Fix the seed of the normal distribution
        element fixed_seed {"true" | "false"}
    }
)

setup_sim =
(
    ## setup initialisation for MD or phase_transition objects.
    element setup {

        ## Number of iteration steps the MD algorithm should run for.
        element steps {

            integer,

            comment
        },

        ## Number of particles per axis (x y z).
        ## This in combination with the lattice formation will yield
        ## a total number of particles equal to:
        ##
        ## SC: particles **3
        ##
        ## FCC: particles **3 *4
        ##
        ## BCC: particles **3 *2
        # element particles {
        #     attribute x { xsd:integer },
        #     attribute y { xsd:integer },
        #     attribute z { xsd:integer }
        # },
        element particles {

            integer_vector,

            comment
        },

        lattice_type,

        iterative_methods,

        options?
    }
)

options =
(
    ## Accuracy of the Radial Distribution Function (RDF).
    ## A large number of bins will result into a very accurate RDF,
    ## however if the simulation is short (small number of steps) the
    ## results will be dominated by statistical noise.
    element rdf_bins { integer }?,

    ## An equilibration period for the RDF in time step units.
    ## The RDF will begin to be collected rdf_equilibrate steps
    ## from the start of the simulation.
    element rdf_equilibrate { integer }?
)

potentials =
(
    ## LJ: Lennard-Jones Potential, 1/r**12 - 1/r**6
    element pair_potential {

        attribute name { "LennardJones" },

        simulation_parameters,

        comment

    }|
    ## GCM: Gaussian Core Model, exp(-r**2)
    element pair_potential {

        attribute name { "GaussianCoreModel" },

        simulation_parameters,

        comment

    }|
    ## EXP: Exponential Potential, A * exp(-r**n)
    element pair_potential {

        attribute name { "Exponential" },

        simulation_parameters,

        pair_potential_parameters,

        comment

    }|
    ## BIP: Bounded Inverse Power, 1/(r**2 + a**2)**n
    element pair_potential {

        attribute name { "BoundedInversePower" },

        simulation_parameters,

        pair_potential_parameters,

        comment

    }
)

simulation_parameters =
(
    ## Fluid density (unitless).
    element density { real },

    ## Fluid temperature (unitless).
    element temperature { real },

    ## Time step
    element dt {
        real,
        element normalise_with_temperature { empty }?
    }?,

    ## Radius cut-off
    ## The simulation is only run within this radius of the box
    element cut_off { real }?
)

pair_potential_parameters =
(
    ## Pair potential strength.
    ## Normal values are between 6 - 12.
    element potential_strength { real },

    ## Softening parameter. Only applicable for BIP and EXP pair potentials.
    ## Normal values usually range between 0 - 2.0. With 0 corresponding to
    ## no-smoothening and 2.0 to a very smoothed fluid.
    element softening_parameter { real }
)

simulation_single =
(
    potentials

)

simulation_compress =
(
    potentials,

    ## The density that the compression aims to reach.
    element final_density { real },

    ## The density increment used to increase/decrease the current density
    ## in order to meed the final density.
    element density_increment { real }

)

simulation =
(
    ## Input variables for a single MD::simulation.
    element simulation_type {

        attribute name { "NormalRun" },

        simulation_single
    }|
    ## Input variables for a compression/phase transition run.
    element simulation_type {

        attribute name { "CompressionRun" },

        simulation_compress
    }|
    ## Run a forward series of compressions/expansions followed by
    ## expansions/compressions in the opposite direction of the phase diagram.
    element simulation_type {

        attribute name { "ReverseCompressionRun" },

        simulation_compress
    }
)

iterative_methods =
(
    ## Step through time using the explicit Verlet algorithm
    element iterative_method {
        attribute name { "VerletAlgorithm" },
        comment
    }|
    ## Step through time using the Runge-Kuta 4th order algorithm
    element iterative_method {
        attribute name { "RK4 "},
        comment
    }
)

start =
(
    ## Input variables for a molecular dynamics simulation
    element input_variables {

        setup_sim,

        io_options,

        simulation,

        ## Enable for unit testing.
        element enable_testing { empty } ?
    }
)